--- a/frontend/src/App.tsx+++ ﻿import React from 'react'
import PriceChart from '@/components/PriceChart'
import DrawingSidePanel from '@/components/DrawingSidePanel'
import IndicatorSettingsDrawer from '@/components/IndicatorSettingsDrawer'
import PluginDrawer from '@/components/PluginDrawer'
import DrawingLayer from '@/components/DrawingLayer'

export default function App() {
  return (
    <div className="h-screen grid grid-cols-[64px_1fr_320px] gap-4 p-4">
      <aside className="p-2 border border-neutral-700 rounded-2xl">
        <DrawingSidePanel />
      </aside>
      <main className="relative border border-neutral-700 rounded-2xl">
        <PriceChart />
        <DrawingLayer />
      </main>
      <aside className="p-4 space-y-4 border border-neutral-700 rounded-2xl">
        <IndicatorSettingsDrawer />
        <PluginDrawer />
      </aside>
    </div>
  )
}
@@ -1 +1,26 @@-b/frontend/src/App.tsx+﻿import React from 'react'
+import PriceChart from '@/components/PriceChart'
+import DrawingSidePanel from '@/components/DrawingSidePanel'
+import IndicatorSettingsDrawer from '@/components/IndicatorSettingsDrawer'
+import PluginDrawer from '@/components/PluginDrawer'
+import DrawingLayer from '@/components/DrawingLayer'
+import DrawingSettings from '@/components/DrawingSettings'
+
+export default function App() {
+  return (
+    <div className="h-screen grid grid-cols-[64px_1fr_340px] gap-4 p-4">
+      <aside className="p-2 border border-neutral-700 rounded-2xl">
+        <DrawingSidePanel />
+      </aside>
+      <main className="relative border border-neutral-700 rounded-2xl">
+        <PriceChart />
+        <DrawingLayer />
+      </main>
+      <aside className="p-4 space-y-4 border border-neutral-700 rounded-2xl">
+        <IndicatorSettingsDrawer />
+        <PluginDrawer />
+        <DrawingSettings />
+      </aside>
+    </div>
+  )
+}
diff --git a/frontend/src/components/DrawingSettings.tsx b/frontend/src/components/DrawingSettings.tsx
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/frontend/src/components/DrawingSettings.tsx
--- /dev/null+++ frontend/src/components/DrawingSettings.tsx@@ -0,0 +1,33 @@+import React from 'react'
+import { useChartStore } from '@/state/store'
+
+export default function DrawingSettings() {
+  const snapEnabled = useChartStore(s => s.drawingSettings.snapEnabled)
+  const snapStep = useChartStore(s => s.drawingSettings.snapStep)
+  const showHandles = useChartStore(s => s.drawingSettings.showHandles)
+  const setDrawingSettings = useChartStore(s => s.setDrawingSettings)
+
+  return (
+    <div>
+      <h2 className="text-lg font-semibold mb-2">Drawing Settings</h2>
+      <div className="space-y-3 text-sm">
+        <label className="flex items-center justify-between">
+          <span>Snap to grid</span>
+          <input type="checkbox" checked={snapEnabled} onChange={() => setDrawingSettings({ snapEnabled: !snapEnabled })} />
+        </label>
+        <label className="flex items-center justify-between">
+          <span>Snap step (px)</span>
+          <input className="ml-2 bg-transparent border px-2 py-1 rounded w-24" type="number" min={2} max={100} step={1}
+            value={snapStep} onChange={e => setDrawingSettings({ snapStep: parseInt(e.target.value || '10', 10) })} />
+        </label>
+        <label className="flex items-center justify-between">
+          <span>Show handles</span>
+          <input type="checkbox" checked={showHandles} onChange={() => setDrawingSettings({ showHandles: !showHandles })} />
+        </label>
+        <div className="text-xs text-neutral-400 pt-1">
+          Tips: press <kbd>S</kbd> to toggle snapping on/off while drawing. Use <kbd>Shift</kbd> for straight lines.
+        </div>
+      </div>
+    </div>
+  )
+}
--- a/frontend/src/state/store.ts+++ ﻿import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type Tool =
  | 'select' | 'trendline' | 'hline' | 'vline' | 'ray'
  | 'arrow' | 'rect' | 'ellipse' | 'text'
  | 'fib' | 'pitchfork' | 'channel' | 'parallel-channel'

export type Theme = 'dark' | 'light' | 'midnight'

type IndicatorSettings = {
  bbPeriod: number
  bbMult: number
  vwapAnchor: 'session' | 'day' | 'week' | 'month' | 'anchored'
  vwapAnchorIndex?: number
  vwmaPeriod: number
  stdChannelPeriod: number
  stdChannelMult: number
}

type IndicatorToggles = {
  showBB: boolean
  showVWAP: boolean
  showVWMA: boolean
  showStdChannels: boolean
  bandFill: boolean
}

type ChartState = {
  timeframe: string
  activeTool: Tool
  theme: Theme
  indicators: IndicatorToggles
  indicatorSettings: IndicatorSettings
  setTool: (t: Tool) => void
  setTheme: (t: Theme) => void
  setTimeframe: (tf: string) => void
  toggleIndicator: (k: keyof IndicatorToggles) => void
  updateIndicatorSettings: (p: Partial<IndicatorSettings>) => void
  // Phase H drawing state
  drawings: any[]
  selection: Set<string>
  addDrawing: (d: any) => void
  updateDrawing: (id: string, fn: (d:any)=>any) => void
  deleteSelected: () => void
  clearSelection: () => void
  setSelection: (sel: Set<string>) => void
  toggleSelect: (id: string, single?: boolean) => void
}


export const useChartStore = create<ChartState>()(persist((set) => ({
  timeframe: '1H',
  activeTool: 'select',
  theme: 'dark',
  indicators: {
    showBB: true,
    showVWAP: true,
    showVWMA: true,
    showStdChannels: false,
    bandFill: true
  },
  indicatorSettings: {
    bbPeriod: 20,
    bbMult: 2,
    vwapAnchor: 'session',
    vwapAnchorIndex: undefined,
    vwmaPeriod: 20,
    stdChannelPeriod: 50,
    stdChannelMult: 2
  },
  setTool: (t) => set({ activeTool: t }),
  setTheme: (t) => set({ theme: t }),
  setTimeframe: (tf) => set({ timeframe: tf }),
  toggleIndicator: (k) => set((s) => ({ indicators: { ...s.indicators, [k]: !s.indicators[k] } })),
  updateIndicatorSettings: (p) => set((s) => ({ indicatorSettings: { ...s.indicatorSettings, ...p } }))
}), { name: 'fynix-chart' }))
@@ -1 +1,86 @@-b/frontend/src/state/store.ts+﻿import { create } from 'zustand'
+import { persist } from 'zustand/middleware'
+
+export type Tool =
+  | 'select' | 'trendline' | 'hline' | 'vline' | 'ray'
+  | 'arrow' | 'rect' | 'ellipse' | 'text'
+  | 'fib' | 'pitchfork' | 'channel' | 'parallel-channel'
+
+export type Theme = 'dark' | 'light' | 'midnight'
+
+type IndicatorSettings = {
+  bbPeriod: number
+  bbMult: number
+  vwapAnchor: 'session' | 'day' | 'week' | 'month' | 'anchored'
+  vwapAnchorIndex?: number
+  vwmaPeriod: number
+  stdChannelPeriod: number
+  stdChannelMult: number
+}
+
+type IndicatorToggles = {
+  showBB: boolean
+  showVWAP: boolean
+  showVWMA: boolean
+  showStdChannels: boolean
+  bandFill: boolean
+}
+
+
+type DrawingSettings = {
+  snapEnabled: boolean
+  snapStep: number   // in pixels
+  showHandles: boolean
+}
+
+type ChartState = {
+  timeframe: string
+  activeTool: Tool
+  theme: Theme
+  indicators: IndicatorToggles
+  indicatorSettings: IndicatorSettings
+  setTool: (t: Tool) => void
+  setTheme: (t: Theme) => void
+  setTimeframe: (tf: string) => void
+  toggleIndicator: (k: keyof IndicatorToggles) => void
+  updateIndicatorSettings: (p: Partial<IndicatorSettings>) => void
+  // Phase H drawing state
+  drawings: any[]
+  selection: Set<string>
+  drawingSettings: DrawingSettings
+  addDrawing: (d: any) => void
+  updateDrawing: (id: string, fn: (d:any)=>any) => void
+  deleteSelected: () => void
+  clearSelection: () => void
+  setSelection: (sel: Set<string>) => void
+  toggleSelect: (id: string, single?: boolean) => void
+  setDrawingSettings: (p: Partial<DrawingSettings>) => void
+}
+
+
+export const useChartStore = create<ChartState>()(persist((set) => ({
+  timeframe: '1H',
+  activeTool: 'select',
+  theme: 'dark',
+  indicators: {
+    showBB: true,
+    showVWAP: true,
+    showVWMA: true,
+    showStdChannels: false,
+    bandFill: true
+  },
+  indicatorSettings: {
+    bbPeriod: 20,
+    bbMult: 2,
+    vwapAnchor: 'session',
+    vwapAnchorIndex: undefined,
+    vwmaPeriod: 20,
+    stdChannelPeriod: 50,
+    stdChannelMult: 2
+  },
+  setTool: (t) => set({ activeTool: t }),
+  setTheme: (t) => set({ theme: t }),
+  setTimeframe: (tf) => set({ timeframe: tf }),
+  toggleIndicator: (k) => set((s) => ({ indicators: { ...s.indicators, [k]: !s.indicators[k] } })),
+  updateIndicatorSettings: (p) => set((s) => ({ indicatorSettings: { ...s.indicatorSettings, ...p } }))
+}), { name: 'fynix-chart' }))
--- a/frontend/src/lib/geom.ts+++ export type Point = { x: number; y: number }
export type Rect = { x: number; y: number; w: number; h: number }

export function distanceToSegment(p: Point, a: Point, b: Point): number {
  const vx = b.x - a.x, vy = b.y - a.y
  const wx = p.x - a.x, wy = p.y - a.y
  const c1 = vx*wx + vy*wy
  if (c1 <= 0) return Math.hypot(p.x-a.x, p.y-a.y)
  const c2 = vx*vx + vy*vy
  if (c2 <= c1) return Math.hypot(p.x-b.x, p.y-b.y)
  const t = c1 / c2
  const proj = { x: a.x + t*vx, y: a.y + t*vy }
  return Math.hypot(p.x - proj.x, p.y - proj.y)
}

export function rectFromPoints(a: Point, b: Point): Rect {
  const x = Math.min(a.x, b.x)
  const y = Math.min(a.y, b.y)
  const w = Math.abs(a.x - b.x)
  const h = Math.abs(a.y - b.y)
  return { x, y, w, h }
}

export function withinRect(p: Point, r: Rect): boolean {
  return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h
}
@@ -1 +1,39 @@-b/frontend/src/lib/geom.ts+export type Point = { x: number; y: number }
+export type Rect = { x: number; y: number; w: number; h: number }
+
+export function distanceToSegment(p: Point, a: Point, b: Point): number {
+  const vx = b.x - a.x, vy = b.y - a.y
+  const wx = p.x - a.x, wy = p.y - a.y
+  const c1 = vx*wx + vy*wy
+  if (c1 <= 0) return Math.hypot(p.x-a.x, p.y-a.y)
+  const c2 = vx*vx + vy*vy
+  if (c2 <= c1) return Math.hypot(p.x-b.x, p.y-b.y)
+  const t = c1 / c2
+  const proj = { x: a.x + t*vx, y: a.y + t*vy }
+  return Math.hypot(p.x - proj.x, p.y - proj.y)
+}
+
+export function rectFromPoints(a: Point, b: Point): Rect {
+  const x = Math.min(a.x, b.x)
+  const y = Math.min(a.y, b.y)
+  const w = Math.abs(a.x - b.x)
+  const h = Math.abs(a.y - b.y)
+  return { x, y, w, h }
+}
+
+export function withinRect(p: Point, r: Rect): boolean {
+  return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h
+}
+
+export function clamp(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, n))
+}
+
+export function normalize(vx: number, vy: number) {
+  const m = Math.hypot(vx, vy) || 1
+  return [vx/m, vy/m] as const
+}
+
+export function perpendicular(vx: number, vy: number) {
+  return [-vy, vx] as const
+}
--- a/frontend/src/lib/drawings.ts+++ import { nanoid } from 'nanoid'
export type Point = { x: number; y: number }
export type DrawingKind = 'trendline' | 'hline' | 'vline' | 'rect' | 'text'
export type Drawing = {
  id: string
  kind: DrawingKind
  points: Point[]
  text?: string
}

export function createDrawing(kind: string, start: Point): Drawing | null {
  switch (kind) {
    case 'trendline': return { id: nanoid(), kind: 'trendline', points: [start, start] }
    case 'hline': return { id: nanoid(), kind: 'hline', points: [start] }
    case 'vline': return { id: nanoid(), kind: 'vline', points: [start] }
    case 'rect': return { id: nanoid(), kind: 'rect', points: [start, start] }
    case 'text': return { id: nanoid(), kind: 'text', points: [start], text: 'Text' }
    default: return null
  }
}

export function updateDrawingGeometry(d: Drawing, p: Point): Drawing {
  switch (d.kind) {
    case 'trendline': return { ...d, points: [d.points[0], p] }
    case 'hline': return { ...d, points: [{ x: d.points[0].x, y: p.y }] }
    case 'vline': return { ...d, points: [{ x: p.x, y: d.points[0].y }] }
    case 'rect': return { ...d, points: [d.points[0], p] }
    case 'text': return { ...d, points: [p] }
    default: return d
  }
}
@@ -1 +1,47 @@-b/frontend/src/lib/drawings.ts+import { nanoid } from 'nanoid'
+export type Point = { x: number; y: number }
+export type DrawingKind = 'trendline' | 'hline' | 'vline' | 'rect' | 'text' | 'arrow' | 'parallel-channel'
+export type Drawing = {
+  id: string
+  kind: DrawingKind
+  points: Point[]
+  text?: string
+}
+
+export function createDrawing(kind: string, start: Point): Drawing | null {
+  switch (kind) {
+    case 'trendline': return { id: nanoid(), kind: 'trendline', points: [start, start] }
+    case 'hline': return { id: nanoid(), kind: 'hline', points: [start] }
+    case 'vline': return { id: nanoid(), kind: 'vline', points: [start] }
+    case 'rect': return { id: nanoid(), kind: 'rect', points: [start, start] }
+    case 'text': return { id: nanoid(), kind: 'text', points: [start], text: 'Text' }
+    case 'arrow': return { id: nanoid(), kind: 'arrow', points: [start, start] }
+    case 'parallel-channel': return { id: nanoid(), kind: 'parallel-channel', points: [start, start, start] }
+    default: return null
+  }
+}
+
+export function updateDrawingGeometry(d: Drawing, p: Point): Drawing {
+  switch (d.kind) {
+    case 'trendline': return { ...d, points: [d.points[0], p] }
+    case 'hline': return { ...d, points: [{ x: d.points[0].x, y: p.y }] }
+    case 'vline': return { ...d, points: [{ x: p.x, y: d.points[0].y }] }
+    case 'rect': return { ...d, points: [d.points[0], p] }
+    case 'text': return { ...d, points: [p] }
+    case 'arrow': return { ...d, points: [d.points[0], p] }
+    case 'parallel-channel': return { ...d, points: [d.points[0], d.points[1], p] }
+    default: return d
+  }
+}
+
+export function arrowHead(from: Point, to: Point, size = 8) {
+  const vx = to.x - from.x, vy = to.y - from.y
+  const m = Math.hypot(vx, vy) || 1
+  const nx = vx / m, ny = vy / m
+  const px = -ny, py = nx
+  const tip = to
+  const base = { x: to.x - nx*size, y: to.y - ny*size }
+  const left = { x: base.x + px*size*0.6, y: base.y + py*size*0.6 }
+  const right = { x: base.x - px*size*0.6, y: base.y - py*size*0.6 }
+  return { tip, left, right }
+}
--- a/frontend/src/components/DrawingLayer.tsx+++ import React from 'react'
import { useChartStore } from '@/state/store'
import { distanceToSegment, rectFromPoints, withinRect } from '@/lib/geom'
import { Drawing, createDrawing, updateDrawingGeometry } from '@/lib/drawings'

type Point = { x: number; y: number }

export default function DrawingLayer() {
  const canvasRef = React.useRef<HTMLCanvasElement>(null)
  const containerRef = React.useRef<HTMLDivElement>(null)
  const s = useChartStore()
  const [drawings, setDrawings] = React.useState<Drawing[]>(s.drawings)
  const [hoverId, setHoverId] = React.useState<string | null>(null)
  const [dragId, setDragId] = React.useState<string | null>(null)
  const [marquee, setMarquee] = React.useState<{start:Point,end:Point}|null>(null)

  // sync from store
  React.useEffect(() => {
    const unsub = useChartStore.subscribe(state => setDrawings(state.drawings))
    return unsub
  }, [])

  React.useEffect(() => {
    const el = canvasRef.current
    const container = containerRef.current
    if (!el || !container) return
    const ctx = el.getContext('2d')!
    const resize = () => {
      const r = container.getBoundingClientRect()
      el.width = Math.floor(r.width * devicePixelRatio)
      el.height = Math.floor(r.height * devicePixelRatio)
      el.style.width = r.width + 'px'
      el.style.height = r.height + 'px'
      drawAll()
    }
    const drawAll = () => {
      ctx.clearRect(0,0,el.width, el.height)
      ctx.save()
      ctx.scale(devicePixelRatio, devicePixelRatio)
      drawings.forEach(d => {
        ctx.strokeStyle = s.selection.has(d.id) ? '#60a5fa' : '#9ca3af'
        ctx.lineWidth = 1.5
        switch (d.kind) {
          case 'trendline': {
            const [a,b] = d.points
            ctx.beginPath()
            ctx.moveTo(a.x, a.y)
            ctx.lineTo(b.x, b.y)
            ctx.stroke()
            break
          }
          case 'hline': {
            const y = d.points[0].y
            ctx.beginPath()
            ctx.moveTo(0, y)
            ctx.lineTo(el.width, y)
            ctx.stroke()
            break
          }
          case 'vline': {
            const x = d.points[0].x
            ctx.beginPath()
            ctx.moveTo(x, 0)
            ctx.lineTo(x, el.height)
            ctx.stroke()
            break
          }
          case 'rect': {
            const r = rectFromPoints(d.points[0], d.points[1])
            ctx.strokeRect(r.x, r.y, r.w, r.h)
            break
          }
          case 'text': {
            const p = d.points[0]
            ctx.fillStyle = '#e5e7eb'
            ctx.font = '12px ui-sans-serif, system-ui'
            ctx.fillText(d.text || 'Text', p.x, p.y)
            break
          }
        }
      })
      if (marquee) {
        const r = rectFromPoints(marquee.start, marquee.end)
        ctx.strokeStyle = '#818cf8'
        ctx.setLineDash([4,4])
        ctx.strokeRect(r.x, r.y, r.w, r.h)
        ctx.setLineDash([])
      }
      ctx.restore()
    }
    resize()
    const ro = new ResizeObserver(resize)
    ro.observe(container)
    return () => ro.disconnect()
  }, [drawings, s.selection, marquee])

  const toLocal = (e: React.MouseEvent): Point => {
    const r = containerRef.current!.getBoundingClientRect()
    return { x: e.clientX - r.left, y: e.clientY - r.top }
  }

  const onMouseDown = (e: React.MouseEvent) => {
    const p = toLocal(e)
    if (s.activeTool === 'select') {
      // start marquee if dragging empty space
      const hit = drawings.find(d => hitTest(d, p) < 6)
      if (!hit) {
        setMarquee({ start: p, end: p })
        s.clearSelection()
        return
      }
      // select & start drag
      s.toggleSelect(hit.id, !e.shiftKey)
      setDragId(hit.id)
      return
    }

    // create a new drawing
    const d = createDrawing(s.activeTool as any, p)
    if (d) {
      s.addDrawing(d)
      setDragId(d.id)
    }
  }

  const onMouseMove = (e: React.MouseEvent) => {
    const p = toLocal(e)
    if (marquee) {
      setMarquee(v => v ? ({...v, end: p}) : null)
      return
    }
    if (dragId) {
      s.updateDrawing(dragId, dr => updateDrawingGeometry(dr, p))
      return
    }
    // hover
    const id = drawings.find(d => hitTest(d, p) < 6)?.id ?? null
    setHoverId(id)
  }

  const onMouseUp = (e: React.MouseEvent) => {
    if (marquee) {
      const r = rectFromPoints(marquee.start, marquee.end)
      const ids = drawings.filter(d => d.points.some(pt => withinRect(pt, r))).map(d => d.id)
      s.setSelection(new Set(ids))
      setMarquee(null)
    }
    setDragId(null)
  }

  const onKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      s.deleteSelected()
    } else if (e.key === 'Escape') {
      s.clearSelection()
      setDragId(null)
      setMarquee(null)
    } else if (e.key === 'a' && (e.ctrlKey || e.metaKey)) {
      s.setSelection(new Set(drawings.map(d => d.id)))
      e.preventDefault()
    }
  }

  return (
    <div ref={containerRef} className="absolute inset-0">
      <canvas
        ref={canvasRef}
        className="absolute inset-0"
        onMouseDown={onMouseDown}
        onMouseMove={onMouseMove}
        onMouseUp={onMouseUp}
        onKeyDown={onKeyDown}
        tabIndex={0}
        style={{ outline: 'none', cursor: s.activeTool==='select' ? (hoverId ? 'pointer' : 'default') : 'crosshair' }}
      />
    </div>
  )
}

function hitTest(d: Drawing, p: Point): number {
  switch (d.kind) {
    case 'trendline': return distanceToSegment(p, d.points[0], d.points[1])
    case 'hline': return Math.abs(p.y - d.points[0].y)
    case 'vline': return Math.abs(p.x - d.points[0].x)
    case 'rect': {
      const r = rectFromPoints(d.points[0], d.points[1])
      const inside = withinRect(p, r)
      return inside ? 0 : 999
    }
    case 'text': {
      // simple point box
      const a = d.points[0]
      const r = { x: a.x, y: a.y-12, w: 80, h: 16 }
      return withinRect(p, r) ? 0 : 999
    }
    default: return 999
  }
}
@@ -1 +1,269 @@-b/frontend/src/components/DrawingLayer.tsx+import React from 'react'
+import { useChartStore } from '@/state/store'
+import { distanceToSegment, rectFromPoints, withinRect, clamp, normalize, perpendicular } from '@/lib/geom'
+import { Drawing, createDrawing, updateDrawingGeometry, arrowHead } from '@/lib/drawings'
+
+type Point = { x: number; y: number }
+
+export default function DrawingLayer() {
+  const canvasRef = React.useRef<HTMLCanvasElement>(null)
+  const containerRef = React.useRef<HTMLDivElement>(null)
+  const s = useChartStore()
+  const [drawings, setDrawings] = React.useState<Drawing[]>(s.drawings)
+  const [hoverId, setHoverId] = React.useState<string | null>(null)
+  const [drag, setDrag] = React.useState<{ id: string; mode: 'move' | 'handle'; handleIdx?: number } | null>(null)
+  const [marquee, setMarquee] = React.useState<{start:Point,end:Point}|null>(null)
+  const drawingSettings = s.drawingSettings
+
+  // sync from store
+  React.useEffect(() => {
+    const unsub = useChartStore.subscribe(state => setDrawings(state.drawings))
+    return unsub
+  }, [])
+
+  React.useEffect(() => {
+    const el = canvasRef.current
+    const container = containerRef.current
+    if (!el || !container) return
+    const ctx = el.getContext('2d')!
+    const resize = () => {
+      const r = container.getBoundingClientRect()
+      el.width = Math.floor(r.width * devicePixelRatio)
+      el.height = Math.floor(r.height * devicePixelRatio)
+      el.style.width = r.width + 'px'
+      el.style.height = r.height + 'px'
+      drawAll()
+    }
+    const drawAll = () => {
+      ctx.clearRect(0,0,el.width, el.height)
+      ctx.save()
+      ctx.scale(devicePixelRatio, devicePixelRatio)
+      drawings.forEach(d => {
+        ctx.strokeStyle = s.selection.has(d.id) ? '#60a5fa' : '#9ca3af'
+        ctx.lineWidth = 1.5
+        switch (d.kind) {
+          case 'trendline': {
+            const [a,b] = d.points
+            ctx.beginPath()
+            ctx.moveTo(a.x, a.y)
+            ctx.lineTo(b.x, b.y)
+            ctx.stroke()
+            if (drawingSettings.showHandles && s.selection.has(d.id)) drawHandles(ctx, [a,b])
+            break
+          }
+          case 'hline': {
+            const y = d.points[0].y
+            ctx.beginPath()
+            ctx.moveTo(0, y)
+            ctx.lineTo(el.width, y)
+            ctx.stroke()
+            if (drawingSettings.showHandles && s.selection.has(d.id)) drawHandles(ctx, [a,b])
+            break
+          }
+          case 'vline': {
+            const x = d.points[0].x
+            ctx.beginPath()
+            ctx.moveTo(x, 0)
+            ctx.lineTo(x, el.height)
+            ctx.stroke()
+            if (drawingSettings.showHandles && s.selection.has(d.id)) drawHandles(ctx, [a,b])
+            break
+          }
+          case 'rect': {
+            const r = rectFromPoints(d.points[0], d.points[1])
+            ctx.strokeRect(r.x, r.y, r.w, r.h)
+            if (drawingSettings.showHandles && s.selection.has(d.id)) {
+              drawHandles(ctx, [
+                {x:r.x, y:r.y}, {x:r.x+r.w, y:r.y},
+                {x:r.x+r.w, y:r.y+r.h}, {x:r.x, y:r.y+r.h}
+              ])
+            }
+            break
+          }
+          case 'text': {
+            const p = d.points[0]
+            ctx.fillStyle = '#e5e7eb'
+            ctx.font = '12px ui-sans-serif, system-ui'
+            ctx.fillText(d.text || 'Text', p.x, p.y)
+            break
+          }
+        }
+      })
+      if (marquee) {
+        const r = rectFromPoints(marquee.start, marquee.end)
+        ctx.strokeStyle = '#818cf8'
+        ctx.setLineDash([4,4])
+        ctx.strokeRect(r.x, r.y, r.w, r.h)
+        ctx.setLineDash([])
+      }
+      ctx.restore()
+    }
+    resize()
+    const ro = new ResizeObserver(resize)
+    ro.observe(container)
+    return () => ro.disconnect()
+  }, [drawings, s.selection, marquee])
+
+  const toLocal = (e: React.MouseEvent): Point => {
+    const r = containerRef.current!.getBoundingClientRect()
+    let x = e.clientX - r.left, y = e.clientY - r.top
+    if (drawingSettings.snapEnabled) {
+      const step = drawingSettings.snapStep
+      x = Math.round(x/step)*step
+      y = Math.round(y/step)*step
+    }
+    return { x, y }
+  }
+
+  const onMouseDown = (e: React.MouseEvent) => {
+    const p = toLocal(e)
+    if (s.activeTool === 'select') {
+      // start marquee if dragging empty space
+      const hit = drawings.find(d => hitTest(d, p).hit)
+      if (!hit) {
+        setMarquee({ start: p, end: p })
+        s.clearSelection()
+        return
+      }
+      // select & start drag
+      s.toggleSelect(hit.id, !e.shiftKey)
+      const info = hitTest(hit, p)
+      setDrag({ id: hit.id, mode: info.handleIdx != null ? 'handle' : 'move', handleIdx: info.handleIdx })
+      return
+    }
+
+    // create a new drawing
+    const d = createDrawing(s.activeTool as any, p)
+    if (d) {
+      s.addDrawing(d)
+      setDrag({ id: d.id, mode: 'handle', handleIdx: undefined })
+    }
+  }
+
+  const onMouseMove = (e: React.MouseEvent) => {
+    const p = toLocal(e)
+    if (marquee) {
+      setMarquee(v => v ? ({...v, end: p}) : null)
+      return
+    }
+    if (drag) {
+      s.updateDrawing(drag.id, dr => updateWithMode(dr, p, drag))
+      return
+    }
+    // hover
+    const first = drawings.map(d => ({...hitTest(d, p), id: d.id})).find(h => h.hit)
+    setHoverId(first?.id ?? null)
+  }
+
+  const onMouseUp = (e: React.MouseEvent) => {
+    if (marquee) {
+      const r = rectFromPoints(marquee.start, marquee.end)
+      const ids = drawings.filter(d => d.points.some(pt => withinRect(pt, r))).map(d => d.id)
+      s.setSelection(new Set(ids))
+      setMarquee(null)
+    }
+    setDrag(null)
+  }
+
+  const onKeyDown = (e: React.KeyboardEvent) => {
+    if (e.key === 'Delete' || e.key === 'Backspace') {
+      s.deleteSelected()
+    } else if (e.key === 'Escape') {
+      s.clearSelection()
+      setDrag(null)
+      setMarquee(null)
+    } else if (e.key === 'a' && (e.ctrlKey || e.metaKey)) {
+      s.setSelection(new Set(drawings.map(d => d.id)))
+      e.preventDefault()
+    } else if (e.key.toLowerCase() === 's') {
+      s.setDrawingSettings({ snapEnabled: !s.drawingSettings.snapEnabled })
+    }
+  }
+
+  return (
+    <div ref={containerRef} className="absolute inset-0">
+      <canvas
+        ref={canvasRef}
+        className="absolute inset-0"
+        onMouseDown={onMouseDown}
+        onMouseMove={onMouseMove}
+        onMouseUp={onMouseUp}
+        onKeyDown={onKeyDown}
+        tabIndex={0}
+        style={{ outline: 'none', cursor: s.activeTool==='select' ? (hoverId ? 'pointer' : 'crosshair') : 'crosshair' }}
+      />
+    </div>
+  )
+}
+
+function hitTest(d: Drawing, p: Point): { hit: boolean; handleIdx?: number } {
+  switch (d.kind) {
+    case 'trendline': {
+      const dist = distanceToSegment(p, d.points[0], d.points[1])
+      const handle = handleIndex(d.points, p)
+      return { hit: dist < 6 || handle != null, handleIdx: handle ?? undefined }
+    }
+    case 'hline': {
+      const dist = Math.abs(p.y - d.points[0].y)
+      return { hit: dist < 6 }
+    }
+    case 'vline': {
+      const dist = Math.abs(p.x - d.points[0].x)
+      return { hit: dist < 6 }
+    }
+    case 'rect': {
+      const r = rectFromPoints(d.points[0], d.points[1])
+      const h = handleIndex([
+        {x:r.x, y:r.y}, {x:r.x+r.w, y:r.y},
+        {x:r.x+r.w, y:r.y+r.h}, {x:r.x, y:r.y+r.h}
+      ], p)
+      const inside = withinRect(p, r) || h != null
+      return { hit: inside, handleIdx: h ?? undefined }
+    }
+    case 'text': {
+      // simple point box
+      const a = d.points[0]
+      const r = { x: a.x, y: a.y-12, w: 80, h: 16 }
+      return { hit: withinRect(p, r) }
+    }
+    default: return 999
+  }
+}
+
+    case 'arrow': {
+      const dist = distanceToSegment(p, d.points[0], d.points[1])
+      const handle = handleIndex(d.points, p)
+      return { hit: dist < 6 || handle != null, handleIdx: handle ?? undefined }
+    }
+    case 'parallel-channel': {
+      const [p1,p2,p3] = d.points
+      const d1 = distanceToSegment(p, p1, p2)
+      const handle = handleIndex([p1,p2,p3], p)
+      return { hit: d1 < 6 || handle != null, handleIdx: handle ?? undefined }
+    }
+    default: return { hit: false }
+  }
+}
+
+function updateWithMode(d: Drawing, p: Point, drag: {mode:'move'|'handle', handleIdx?: number}) {
+  if (drag.mode === 'handle') return updateDrawingGeometry(d, p)
+  // move
+  const p0 = d.points[0]
+  const dx = p.x - p0.x
+  const dy = p.y - p0.y
+  return { ...d, points: d.points.map(pt => ({ x: pt.x + dx, y: pt.y + dy })) }
+}
+
+function drawHandles(ctx: CanvasRenderingContext2D, pts: Point[]) {
+  ctx.save()
+  ctx.fillStyle = '#60a5fa'
+  pts.forEach(p => ctx.fillRect(p.x-3, p.y-3, 6, 6))
+  ctx.restore()
+}
+
+function handleIndex(pts: Point[], p: Point): number | null {
+  for (let i=0;i<pts.length;i++) {
+    if (Math.abs(pts[i].x - p.x) <= 6 && Math.abs(pts[i].y - p.y) <= 6) return i
+  }
+  return null
+}
