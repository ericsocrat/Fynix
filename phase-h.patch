--- a/frontend/src/App.tsx+++ ﻿import React from 'react'
import PriceChart from '@/components/PriceChart'
import DrawingSidePanel from '@/components/DrawingSidePanel'
import IndicatorSettingsDrawer from '@/components/IndicatorSettingsDrawer'
import PluginDrawer from '@/components/PluginDrawer'

export default function App() {
  return (
    <div className="h-screen grid grid-cols-[64px_1fr_320px] gap-4 p-4">
      <aside className="p-2 border border-neutral-700 rounded-2xl">
        <DrawingSidePanel />
      </aside>
      <main className="relative border border-neutral-700 rounded-2xl">
        <PriceChart />
      </main>
      <aside className="p-4 space-y-4 border border-neutral-700 rounded-2xl">
        <IndicatorSettingsDrawer />
        <PluginDrawer />
      </aside>
    </div>
  )
}
@@ -1 +1,24 @@-b/frontend/src/App.tsx+﻿import React from 'react'
+import PriceChart from '@/components/PriceChart'
+import DrawingSidePanel from '@/components/DrawingSidePanel'
+import IndicatorSettingsDrawer from '@/components/IndicatorSettingsDrawer'
+import PluginDrawer from '@/components/PluginDrawer'
+import DrawingLayer from '@/components/DrawingLayer'
+
+export default function App() {
+  return (
+    <div className="h-screen grid grid-cols-[64px_1fr_320px] gap-4 p-4">
+      <aside className="p-2 border border-neutral-700 rounded-2xl">
+        <DrawingSidePanel />
+      </aside>
+      <main className="relative border border-neutral-700 rounded-2xl">
+        <PriceChart />
+        <DrawingLayer />
+      </main>
+      <aside className="p-4 space-y-4 border border-neutral-700 rounded-2xl">
+        <IndicatorSettingsDrawer />
+        <PluginDrawer />
+      </aside>
+    </div>
+  )
+}
--- a/frontend/src/state/store.ts+++ ﻿import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type Tool =
  | 'select' | 'trendline' | 'hline' | 'vline' | 'ray'
  | 'arrow' | 'rect' | 'ellipse' | 'text'
  | 'fib' | 'pitchfork' | 'channel' | 'parallel-channel'

export type Theme = 'dark' | 'light' | 'midnight'

type IndicatorSettings = {
  bbPeriod: number
  bbMult: number
  vwapAnchor: 'session' | 'day' | 'week' | 'month' | 'anchored'
  vwapAnchorIndex?: number
  vwmaPeriod: number
  stdChannelPeriod: number
  stdChannelMult: number
}

type IndicatorToggles = {
  showBB: boolean
  showVWAP: boolean
  showVWMA: boolean
  showStdChannels: boolean
  bandFill: boolean
}

type ChartState = {
  timeframe: string
  activeTool: Tool
  theme: Theme
  indicators: IndicatorToggles
  indicatorSettings: IndicatorSettings
  setTool: (t: Tool) => void
  setTheme: (t: Theme) => void
  setTimeframe: (tf: string) => void
  toggleIndicator: (k: keyof IndicatorToggles) => void
  updateIndicatorSettings: (p: Partial<IndicatorSettings>) => void
}

export const useChartStore = create<ChartState>()(persist((set) => ({
  timeframe: '1H',
  activeTool: 'select',
  theme: 'dark',
  indicators: {
    showBB: true,
    showVWAP: true,
    showVWMA: true,
    showStdChannels: false,
    bandFill: true
  },
  indicatorSettings: {
    bbPeriod: 20,
    bbMult: 2,
    vwapAnchor: 'session',
    vwapAnchorIndex: undefined,
    vwmaPeriod: 20,
    stdChannelPeriod: 50,
    stdChannelMult: 2
  },
  setTool: (t) => set({ activeTool: t }),
  setTheme: (t) => set({ theme: t }),
  setTimeframe: (tf) => set({ timeframe: tf }),
  toggleIndicator: (k) => set((s) => ({ indicators: { ...s.indicators, [k]: !s.indicators[k] } })),
  updateIndicatorSettings: (p) => set((s) => ({ indicatorSettings: { ...s.indicatorSettings, ...p } }))
}), { name: 'fynix-chart' }))
@@ -1 +1,77 @@-b/frontend/src/state/store.ts+﻿import { create } from 'zustand'
+import { persist } from 'zustand/middleware'
+
+export type Tool =
+  | 'select' | 'trendline' | 'hline' | 'vline' | 'ray'
+  | 'arrow' | 'rect' | 'ellipse' | 'text'
+  | 'fib' | 'pitchfork' | 'channel' | 'parallel-channel'
+
+export type Theme = 'dark' | 'light' | 'midnight'
+
+type IndicatorSettings = {
+  bbPeriod: number
+  bbMult: number
+  vwapAnchor: 'session' | 'day' | 'week' | 'month' | 'anchored'
+  vwapAnchorIndex?: number
+  vwmaPeriod: number
+  stdChannelPeriod: number
+  stdChannelMult: number
+}
+
+type IndicatorToggles = {
+  showBB: boolean
+  showVWAP: boolean
+  showVWMA: boolean
+  showStdChannels: boolean
+  bandFill: boolean
+}
+
+type ChartState = {
+  timeframe: string
+  activeTool: Tool
+  theme: Theme
+  indicators: IndicatorToggles
+  indicatorSettings: IndicatorSettings
+  setTool: (t: Tool) => void
+  setTheme: (t: Theme) => void
+  setTimeframe: (tf: string) => void
+  toggleIndicator: (k: keyof IndicatorToggles) => void
+  updateIndicatorSettings: (p: Partial<IndicatorSettings>) => void
+  // Phase H drawing state
+  drawings: any[]
+  selection: Set<string>
+  addDrawing: (d: any) => void
+  updateDrawing: (id: string, fn: (d:any)=>any) => void
+  deleteSelected: () => void
+  clearSelection: () => void
+  setSelection: (sel: Set<string>) => void
+  toggleSelect: (id: string, single?: boolean) => void
+}
+
+
+export const useChartStore = create<ChartState>()(persist((set) => ({
+  timeframe: '1H',
+  activeTool: 'select',
+  theme: 'dark',
+  indicators: {
+    showBB: true,
+    showVWAP: true,
+    showVWMA: true,
+    showStdChannels: false,
+    bandFill: true
+  },
+  indicatorSettings: {
+    bbPeriod: 20,
+    bbMult: 2,
+    vwapAnchor: 'session',
+    vwapAnchorIndex: undefined,
+    vwmaPeriod: 20,
+    stdChannelPeriod: 50,
+    stdChannelMult: 2
+  },
+  setTool: (t) => set({ activeTool: t }),
+  setTheme: (t) => set({ theme: t }),
+  setTimeframe: (tf) => set({ timeframe: tf }),
+  toggleIndicator: (k) => set((s) => ({ indicators: { ...s.indicators, [k]: !s.indicators[k] } })),
+  updateIndicatorSettings: (p) => set((s) => ({ indicatorSettings: { ...s.indicatorSettings, ...p } }))
+}), { name: 'fynix-chart' }))
diff --git a/frontend/src/components/DrawingLayer.tsx b/frontend/src/components/DrawingLayer.tsx
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/frontend/src/components/DrawingLayer.tsx
--- /dev/null+++ frontend/src/components/DrawingLayer.tsx@@ -0,0 +1,198 @@+import React from 'react'
+import { useChartStore } from '@/state/store'
+import { distanceToSegment, rectFromPoints, withinRect } from '@/lib/geom'
+import { Drawing, createDrawing, updateDrawingGeometry } from '@/lib/drawings'
+
+type Point = { x: number; y: number }
+
+export default function DrawingLayer() {
+  const canvasRef = React.useRef<HTMLCanvasElement>(null)
+  const containerRef = React.useRef<HTMLDivElement>(null)
+  const s = useChartStore()
+  const [drawings, setDrawings] = React.useState<Drawing[]>(s.drawings)
+  const [hoverId, setHoverId] = React.useState<string | null>(null)
+  const [dragId, setDragId] = React.useState<string | null>(null)
+  const [marquee, setMarquee] = React.useState<{start:Point,end:Point}|null>(null)
+
+  // sync from store
+  React.useEffect(() => {
+    const unsub = useChartStore.subscribe(state => setDrawings(state.drawings))
+    return unsub
+  }, [])
+
+  React.useEffect(() => {
+    const el = canvasRef.current
+    const container = containerRef.current
+    if (!el || !container) return
+    const ctx = el.getContext('2d')!
+    const resize = () => {
+      const r = container.getBoundingClientRect()
+      el.width = Math.floor(r.width * devicePixelRatio)
+      el.height = Math.floor(r.height * devicePixelRatio)
+      el.style.width = r.width + 'px'
+      el.style.height = r.height + 'px'
+      drawAll()
+    }
+    const drawAll = () => {
+      ctx.clearRect(0,0,el.width, el.height)
+      ctx.save()
+      ctx.scale(devicePixelRatio, devicePixelRatio)
+      drawings.forEach(d => {
+        ctx.strokeStyle = s.selection.has(d.id) ? '#60a5fa' : '#9ca3af'
+        ctx.lineWidth = 1.5
+        switch (d.kind) {
+          case 'trendline': {
+            const [a,b] = d.points
+            ctx.beginPath()
+            ctx.moveTo(a.x, a.y)
+            ctx.lineTo(b.x, b.y)
+            ctx.stroke()
+            break
+          }
+          case 'hline': {
+            const y = d.points[0].y
+            ctx.beginPath()
+            ctx.moveTo(0, y)
+            ctx.lineTo(el.width, y)
+            ctx.stroke()
+            break
+          }
+          case 'vline': {
+            const x = d.points[0].x
+            ctx.beginPath()
+            ctx.moveTo(x, 0)
+            ctx.lineTo(x, el.height)
+            ctx.stroke()
+            break
+          }
+          case 'rect': {
+            const r = rectFromPoints(d.points[0], d.points[1])
+            ctx.strokeRect(r.x, r.y, r.w, r.h)
+            break
+          }
+          case 'text': {
+            const p = d.points[0]
+            ctx.fillStyle = '#e5e7eb'
+            ctx.font = '12px ui-sans-serif, system-ui'
+            ctx.fillText(d.text || 'Text', p.x, p.y)
+            break
+          }
+        }
+      })
+      if (marquee) {
+        const r = rectFromPoints(marquee.start, marquee.end)
+        ctx.strokeStyle = '#818cf8'
+        ctx.setLineDash([4,4])
+        ctx.strokeRect(r.x, r.y, r.w, r.h)
+        ctx.setLineDash([])
+      }
+      ctx.restore()
+    }
+    resize()
+    const ro = new ResizeObserver(resize)
+    ro.observe(container)
+    return () => ro.disconnect()
+  }, [drawings, s.selection, marquee])
+
+  const toLocal = (e: React.MouseEvent): Point => {
+    const r = containerRef.current!.getBoundingClientRect()
+    return { x: e.clientX - r.left, y: e.clientY - r.top }
+  }
+
+  const onMouseDown = (e: React.MouseEvent) => {
+    const p = toLocal(e)
+    if (s.activeTool === 'select') {
+      // start marquee if dragging empty space
+      const hit = drawings.find(d => hitTest(d, p) < 6)
+      if (!hit) {
+        setMarquee({ start: p, end: p })
+        s.clearSelection()
+        return
+      }
+      // select & start drag
+      s.toggleSelect(hit.id, !e.shiftKey)
+      setDragId(hit.id)
+      return
+    }
+
+    // create a new drawing
+    const d = createDrawing(s.activeTool as any, p)
+    if (d) {
+      s.addDrawing(d)
+      setDragId(d.id)
+    }
+  }
+
+  const onMouseMove = (e: React.MouseEvent) => {
+    const p = toLocal(e)
+    if (marquee) {
+      setMarquee(v => v ? ({...v, end: p}) : null)
+      return
+    }
+    if (dragId) {
+      s.updateDrawing(dragId, dr => updateDrawingGeometry(dr, p))
+      return
+    }
+    // hover
+    const id = drawings.find(d => hitTest(d, p) < 6)?.id ?? null
+    setHoverId(id)
+  }
+
+  const onMouseUp = (e: React.MouseEvent) => {
+    if (marquee) {
+      const r = rectFromPoints(marquee.start, marquee.end)
+      const ids = drawings.filter(d => d.points.some(pt => withinRect(pt, r))).map(d => d.id)
+      s.setSelection(new Set(ids))
+      setMarquee(null)
+    }
+    setDragId(null)
+  }
+
+  const onKeyDown = (e: React.KeyboardEvent) => {
+    if (e.key === 'Delete' || e.key === 'Backspace') {
+      s.deleteSelected()
+    } else if (e.key === 'Escape') {
+      s.clearSelection()
+      setDragId(null)
+      setMarquee(null)
+    } else if (e.key === 'a' && (e.ctrlKey || e.metaKey)) {
+      s.setSelection(new Set(drawings.map(d => d.id)))
+      e.preventDefault()
+    }
+  }
+
+  return (
+    <div ref={containerRef} className="absolute inset-0">
+      <canvas
+        ref={canvasRef}
+        className="absolute inset-0"
+        onMouseDown={onMouseDown}
+        onMouseMove={onMouseMove}
+        onMouseUp={onMouseUp}
+        onKeyDown={onKeyDown}
+        tabIndex={0}
+        style={{ outline: 'none', cursor: s.activeTool==='select' ? (hoverId ? 'pointer' : 'default') : 'crosshair' }}
+      />
+    </div>
+  )
+}
+
+function hitTest(d: Drawing, p: Point): number {
+  switch (d.kind) {
+    case 'trendline': return distanceToSegment(p, d.points[0], d.points[1])
+    case 'hline': return Math.abs(p.y - d.points[0].y)
+    case 'vline': return Math.abs(p.x - d.points[0].x)
+    case 'rect': {
+      const r = rectFromPoints(d.points[0], d.points[1])
+      const inside = withinRect(p, r)
+      return inside ? 0 : 999
+    }
+    case 'text': {
+      // simple point box
+      const a = d.points[0]
+      const r = { x: a.x, y: a.y-12, w: 80, h: 16 }
+      return withinRect(p, r) ? 0 : 999
+    }
+    default: return 999
+  }
+}
diff --git a/frontend/src/lib/geom.ts b/frontend/src/lib/geom.ts
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/frontend/src/lib/geom.ts
--- /dev/null+++ frontend/src/lib/geom.ts@@ -0,0 +1,26 @@+export type Point = { x: number; y: number }
+export type Rect = { x: number; y: number; w: number; h: number }
+
+export function distanceToSegment(p: Point, a: Point, b: Point): number {
+  const vx = b.x - a.x, vy = b.y - a.y
+  const wx = p.x - a.x, wy = p.y - a.y
+  const c1 = vx*wx + vy*wy
+  if (c1 <= 0) return Math.hypot(p.x-a.x, p.y-a.y)
+  const c2 = vx*vx + vy*vy
+  if (c2 <= c1) return Math.hypot(p.x-b.x, p.y-b.y)
+  const t = c1 / c2
+  const proj = { x: a.x + t*vx, y: a.y + t*vy }
+  return Math.hypot(p.x - proj.x, p.y - proj.y)
+}
+
+export function rectFromPoints(a: Point, b: Point): Rect {
+  const x = Math.min(a.x, b.x)
+  const y = Math.min(a.y, b.y)
+  const w = Math.abs(a.x - b.x)
+  const h = Math.abs(a.y - b.y)
+  return { x, y, w, h }
+}
+
+export function withinRect(p: Point, r: Rect): boolean {
+  return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h
+}
diff --git a/frontend/src/lib/drawings.ts b/frontend/src/lib/drawings.ts
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/frontend/src/lib/drawings.ts
--- /dev/null+++ frontend/src/lib/drawings.ts@@ -0,0 +1,31 @@+import { nanoid } from 'nanoid'
+export type Point = { x: number; y: number }
+export type DrawingKind = 'trendline' | 'hline' | 'vline' | 'rect' | 'text'
+export type Drawing = {
+  id: string
+  kind: DrawingKind
+  points: Point[]
+  text?: string
+}
+
+export function createDrawing(kind: string, start: Point): Drawing | null {
+  switch (kind) {
+    case 'trendline': return { id: nanoid(), kind: 'trendline', points: [start, start] }
+    case 'hline': return { id: nanoid(), kind: 'hline', points: [start] }
+    case 'vline': return { id: nanoid(), kind: 'vline', points: [start] }
+    case 'rect': return { id: nanoid(), kind: 'rect', points: [start, start] }
+    case 'text': return { id: nanoid(), kind: 'text', points: [start], text: 'Text' }
+    default: return null
+  }
+}
+
+export function updateDrawingGeometry(d: Drawing, p: Point): Drawing {
+  switch (d.kind) {
+    case 'trendline': return { ...d, points: [d.points[0], p] }
+    case 'hline': return { ...d, points: [{ x: d.points[0].x, y: p.y }] }
+    case 'vline': return { ...d, points: [{ x: p.x, y: d.points[0].y }] }
+    case 'rect': return { ...d, points: [d.points[0], p] }
+    case 'text': return { ...d, points: [p] }
+    default: return d
+  }
+}
--- a/frontend/package.json+++ {
  "name": "fynix-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start -p 3000",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.2.5",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "swr": "2.2.5",
    "lightweight-charts": "4.2.2"
  },
  "devDependencies": {
    "@types/node": "20.12.12",
    "@types/react": "18.2.66",
    "@types/react-dom": "18.2.22",
    "autoprefixer": "10.4.19",
    "postcss": "8.4.41",
    "tailwindcss": "3.4.10",
    "typescript": "5.5.4"
  }
}
@@ -1 +1,28 @@-b/frontend/package.json+{
+  "name": "fynix-frontend",
+  "version": "0.1.0",
+  "private": true,
+  "scripts": {
+    "dev": "next dev -p 3000",
+    "build": "next build",
+    "start": "next start -p 3000",
+    "lint": "next lint"
+  },
+  "dependencies": {
+    "next": "14.2.5",
+    "react": "18.3.1",
+    "react-dom": "18.3.1",
+    "swr": "2.2.5",
+    "lightweight-charts": "4.2.2",
+    "nanoid": "5.0.6"
+  },
+  "devDependencies": {
+    "@types/node": "20.12.12",
+    "@types/react": "18.2.66",
+    "@types/react-dom": "18.2.22",
+    "autoprefixer": "10.4.19",
+    "postcss": "8.4.41",
+    "tailwindcss": "3.4.10",
+    "typescript": "5.5.4"
+  }
+}
